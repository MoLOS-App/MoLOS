import tailwindcss from '@tailwindcss/vite';
import { defineConfig } from 'vite';
import { playwright } from '@vitest/browser-playwright';
import { sveltekit } from '@sveltejs/kit/vite';
import {
	existsSync,
	lstatSync,
	mkdirSync,
	readdirSync,
	realpathSync,
	rmSync,
	symlinkSync,
	readFileSync
} from 'fs';
import path from 'path';
import { createRequire } from 'module';
import { SYMLINK_CONFIG } from './module-management/config/symlink-config';

/**
 * Module link state file
 * This file is generated by scripts/link-modules.ts during the sync process
 */
const LINK_STATE_FILE = path.resolve(process.cwd(), '.molo-module-links.json');

interface ModuleLinkState {
	linkedModules: string[];
	computedAt: string;
}

/**
 * Quick validation for modules during Vite linking
 * Similar to module-validator but optimized for build-time performance
 */
function quickValidateModule(moduleId: string, modulePath: string): {
	valid: boolean;
	error?: string
} {
	// 1. Check manifest exists
	const manifestPath = path.join(modulePath, 'manifest.yaml');
	if (!existsSync(manifestPath)) {
		return { valid: false, error: 'Missing manifest.yaml' };
	}

	// 2. Check config exists
	const configPath = path.join(modulePath, 'config.ts');
	if (!existsSync(configPath)) {
		return { valid: false, error: 'Missing config.ts' };
	}

	// 3. Check for broken symlinks
	try {
		const stats = lstatSync(modulePath);
		if (stats.isSymbolicLink() && !existsSync(modulePath)) {
			return { valid: false, error: 'Broken symlink' };
		}
	} catch {
		return { valid: false, error: 'Cannot access module directory' };
	}

	// 4. Basic YAML syntax check (quick)
	try {
		const yamlContent = readFileSync(manifestPath, 'utf-8');
		// Check for basic YAML structure issues
		if (!yamlContent.includes('id:') || !yamlContent.includes('name:')) {
			return { valid: false, error: 'Invalid manifest (missing required fields)' };
		}
	} catch {
		return { valid: false, error: 'Cannot read manifest' };
	}

	return { valid: true };
}

/**
 * MoLOS Module Linker
 * This runs during Vite config load to ensure external modules are symlinked
 * before SvelteKit starts its route discovery.
 */
function linkExternalModules() {
	const EXTERNAL_DIR = path.resolve('external_modules');
	const allowParentModules =
		process.env.MOLOS_ALLOW_PARENT_MODULES === 'true' || process.env.NODE_ENV !== 'production';
	const allowedRoots = [EXTERNAL_DIR];
	if (allowParentModules) {
		allowedRoots.push(path.resolve('..'));
	}
	const INTERNAL_CONFIG_DIR = path.resolve('src/lib/config/external_modules');
	const LEGACY_CONFIG_DIR = path.resolve('src/lib/config/modules');
	const UI_ROUTES_DIR = path.resolve('src/routes/ui/(modules)/(external_modules)');
	const API_ROUTES_DIR = path.resolve('src/routes/api/(external_modules)');
	const LIB_SYMLINK_DIRS = [
		SYMLINK_CONFIG.componentsDir,
		SYMLINK_CONFIG.modelsDir,
		SYMLINK_CONFIG.repositoriesDir,
		SYMLINK_CONFIG.storesDir,
		SYMLINK_CONFIG.utilsDir,
		SYMLINK_CONFIG.serverAiDir,
		SYMLINK_CONFIG.dbSchemaDir
	];

	// Helper to safely remove a path (including broken symlinks)
	const safeRemove = (p: string) => {
		try {
			rmSync(p, { recursive: true, force: true });
		} catch (e) {
			console.error(`[Vite] Failed to remove path ${p}:`, e);
		}
	};

	// 0. Cleanup broken or stale symlinks in the target directories first
	// This prevents ENOENT errors when Vite tries to stat broken links
	[
		INTERNAL_CONFIG_DIR,
		UI_ROUTES_DIR,
		API_ROUTES_DIR,
		LEGACY_CONFIG_DIR,
		...LIB_SYMLINK_DIRS
	].forEach((dir) => {
		if (existsSync(dir)) {
			const entries = readdirSync(dir, { withFileTypes: true });
			for (const entry of entries) {
				const fullPath = path.join(dir, entry.name);
				try {
					// Check if it's a symlink and if it's broken
					const stats = lstatSync(fullPath);
					if (stats.isSymbolicLink()) {
						if (!existsSync(fullPath)) {
							console.log(`[Vite] Removing broken symlink: ${fullPath}`);
							safeRemove(fullPath);
						} else if (dir === LEGACY_CONFIG_DIR) {
							console.log(`[Vite] Removing legacy module config symlink: ${fullPath}`);
							safeRemove(fullPath);
						}
					}
				} catch (e) {
					console.log(`[Vite] Error while removing path ${fullPath}:`, e);
					safeRemove(fullPath);
				}
			}
		}
	});

	if (!existsSync(EXTERNAL_DIR)) return;

	let modules: string[] = [];
	try {
		modules = readdirSync(EXTERNAL_DIR, { withFileTypes: true })
			.filter((dirent) => dirent.isDirectory() || dirent.isSymbolicLink())
			.map((dirent) => dirent.name);
	} catch (e) {
		console.error('[Vite] Failed to read external modules directory:', e);
		return;
	}

	// Try to use pre-generated link state first (faster, no DB read)
	const linkState = getLinkState();
	const activeModuleIds = linkState ? new Set(linkState.linkedModules) : getActiveModulesFromDb();

	// Filter out disabled modules from database
	if (activeModuleIds) {
		const disabledModuleIds = getDisabledModulesFromDb();
		for (const disabledId of disabledModuleIds) {
			activeModuleIds.delete(disabledId);
			console.log(`[Vite] Skipping disabled module: ${disabledId}`);
		}
	}

	if (activeModuleIds) {
		const pruneSymlinks = (dir: string, toModuleId: (name: string) => string) => {
			if (!existsSync(dir)) return;
			const entries = readdirSync(dir, { withFileTypes: true });
			for (const entry of entries) {
				if (!entry.isSymbolicLink()) continue;
				const moduleId = toModuleId(entry.name);
				if (!activeModuleIds.has(moduleId)) {
					safeRemove(path.join(dir, entry.name));
				}
			}
		};

		pruneSymlinks(INTERNAL_CONFIG_DIR, (name) => name.replace(/\.ts$/, ''));
		pruneSymlinks(LEGACY_CONFIG_DIR, (name) => name.replace(/\.ts$/, ''));
		pruneSymlinks(UI_ROUTES_DIR, (name) => name);
		pruneSymlinks(API_ROUTES_DIR, (name) => name);
		LIB_SYMLINK_DIRS.forEach((dir) => pruneSymlinks(dir, (name) => name));

		modules = modules.filter((moduleId) => activeModuleIds.has(moduleId));
	}

	console.log(`[Vite] Linking ${modules.length} external modules...`);

	for (const moduleId of modules) {
		if (!/^[a-zA-Z0-9_-]+$/.test(moduleId)) {
			console.warn(`[Vite] Skipping module with invalid ID: ${moduleId}`);
			continue;
		}

		const modulePath = path.join(EXTERNAL_DIR, moduleId);
		if (!isPathWithinRoots(modulePath, allowedRoots)) {
			console.warn(`[Vite] Skipping module outside allowed roots: ${moduleId}`);
			continue;
		}

		// Quick validation before linking
		const validation = quickValidateModule(moduleId, modulePath);
		if (!validation.valid) {
			console.warn(`[Vite] Skipping invalid module ${moduleId}: ${validation.error}`);
			// Mark for disable (async, non-blocking)
			markModuleInvalidInDb(moduleId, validation.error).catch(() => {});
			continue;
		}

		try {
			// 1. Link to config registry
			const configSource = path.join(modulePath, 'config.ts');
			if (existsSync(configSource)) {
				const configDest = path.join(INTERNAL_CONFIG_DIR, `${moduleId}.ts`);
				safeRemove(configDest);
				if (!existsSync(path.dirname(configDest)))
					mkdirSync(path.dirname(configDest), { recursive: true });
				symlinkSync(configSource, configDest, 'file');
			}

			// 2. Link UI routes
			const uiSource = path.join(modulePath, 'routes/ui');
			if (existsSync(uiSource)) {
				const uiDest = path.join(UI_ROUTES_DIR, moduleId);
				safeRemove(uiDest);
				if (!existsSync(path.dirname(uiDest))) mkdirSync(path.dirname(uiDest), { recursive: true });
				symlinkSync(uiSource, uiDest, 'dir');
			}

			// 3. Link API routes
			const apiSource = path.join(modulePath, 'routes/api');
			if (existsSync(apiSource)) {
				const apiDest = path.join(API_ROUTES_DIR, moduleId);
				safeRemove(apiDest);
				if (!existsSync(path.dirname(apiDest)))
					mkdirSync(path.dirname(apiDest), { recursive: true });
				symlinkSync(apiSource, apiDest, 'dir');
			}

			// 4. Link lib directories (stores, components, models, repositories, utils, server/ai, server/db/schema)
			const libMappings: Array<{ source: string; dest: string }> = [
				{
					source: path.join(modulePath, 'lib/stores'),
					dest: path.join(SYMLINK_CONFIG.storesDir, moduleId)
				},
				{
					source: path.join(modulePath, 'lib/components'),
					dest: path.join(SYMLINK_CONFIG.componentsDir, moduleId)
				},
				{
					source: path.join(modulePath, 'lib/models'),
					dest: path.join(SYMLINK_CONFIG.modelsDir, moduleId)
				},
				{
					source: path.join(modulePath, 'lib/repositories'),
					dest: path.join(SYMLINK_CONFIG.repositoriesDir, moduleId)
				},
				{
					source: path.join(modulePath, 'lib/utils'),
					dest: path.join(SYMLINK_CONFIG.utilsDir, moduleId)
				},
				{
					source: path.join(modulePath, 'lib/server/ai'),
					dest: path.join(SYMLINK_CONFIG.serverAiDir, moduleId)
				},
				{
					source: path.join(modulePath, 'lib/server/db/schema'),
					dest: path.join(SYMLINK_CONFIG.dbSchemaDir, moduleId)
				}
			];

			for (const { source, dest } of libMappings) {
				if (existsSync(source)) {
					safeRemove(dest);
					if (!existsSync(path.dirname(dest))) mkdirSync(path.dirname(dest), { recursive: true });
					symlinkSync(source, dest, 'dir');
				}
			}
		} catch (e) {
			console.error(`[Vite] Failed to link module ${moduleId}:`, e);
		}
	}
}

function isPathWithinRoots(targetPath: string, roots: string[]): boolean {
	let realTarget: string;
	try {
		realTarget = realpathSync(targetPath);
	} catch {
		return false;
	}

	return roots.some((root) => {
		let realRoot: string;
		try {
			realRoot = realpathSync(root);
		} catch {
			realRoot = path.resolve(root);
		}
		const relative = path.relative(realRoot, realTarget);
		return relative === '' || (!relative.startsWith('..') && !path.isAbsolute(relative));
	});
}

function getLinkState(): ModuleLinkState | null {
	try {
		if (existsSync(LINK_STATE_FILE)) {
			const content = readFileSync(LINK_STATE_FILE, 'utf-8');
			return JSON.parse(content) as ModuleLinkState;
		}
	} catch (e) {
		console.warn('[Vite] Failed to read link state file:', e);
	}
	return null;
}

function normalizeDbPath(raw: string): string {
	if (raw.startsWith('file:')) return raw.replace(/^file:/, '');
	if (raw.startsWith('sqlite://')) return raw.replace(/^sqlite:\/\//, '');
	if (raw.startsWith('sqlite:')) return raw.replace(/^sqlite:/, '');
	return raw;
}

function getActiveModulesFromDb(): Set<string> | null {
	const dbUrl = process.env.DATABASE_URL;
	if (!dbUrl) return new Set();

	const dbPath = normalizeDbPath(dbUrl);
	try {
		const require = createRequire(import.meta.url);
		const Database = require('better-sqlite3');
		const db = new Database(dbPath, { readonly: true, fileMustExist: true });
		const rows = db.prepare('select id, status from settings_external_modules').all();
		db.close();
		return new Set(
			rows
				.filter((row: { status: string }) => row.status === 'active')
				.map((row: { id: string }) => row.id)
		);
	} catch (e) {
		console.warn('[Vite] Unable to read external module status from DB:', e);
		return new Set();
	}
}

/**
 * Get disabled modules from database
 * Returns array of disabled module IDs
 */
function getDisabledModulesFromDb(): string[] {
	const dbUrl = process.env.DATABASE_URL;
	if (!dbUrl) return [];

	const dbPath = normalizeDbPath(dbUrl);
	try {
		const require = createRequire(import.meta.url);
		const Database = require('better-sqlite3');
		const db = new Database(dbPath, { readonly: true, fileMustExist: true });
		const rows = db.prepare('select id from settings_external_modules where status = ?').all('disabled');
		db.close();
		return rows.map((row: { id: string }) => row.id);
	} catch (e) {
		console.warn('[Vite] Unable to read disabled modules from DB:', e);
		return [];
	}
}

/**
 * Mark a module as disabled in the database due to validation failure
 * This is async and non-blocking to avoid slowing down the build
 */
async function markModuleInvalidInDb(moduleId: string, error: string | undefined): Promise<void> {
	const dbUrl = process.env.DATABASE_URL;
	if (!dbUrl) return;

	const dbPath = normalizeDbPath(dbUrl);
	try {
		const require = createRequire(import.meta.url);
		const Database = require('better-sqlite3');
		const db = new Database(dbPath);

		db.prepare(`
			UPDATE settings_external_modules
			SET status = 'disabled',
			    last_error = ?
			WHERE id = ?
		`).run(error || 'Validation failed', moduleId);

		db.close();
		console.warn(`[Vite] Module ${moduleId} marked as disabled in database`);
	} catch (e) {
		console.warn(`[Vite] Could not mark module ${moduleId} as disabled:`, e);
	}
}

// Execute linking immediately
linkExternalModules();

export default defineConfig({
	plugins: [tailwindcss(), sveltekit()],

	resolve: {
		preserveSymlinks: true
	},

	server: {
		fs: {
			allow: [
				process.cwd(),
				path.resolve('external_modules'),
				...(process.env.MOLOS_ALLOW_PARENT_MODULES === 'true' ||
				process.env.NODE_ENV !== 'production'
					? [path.resolve('..')]
					: [])
			]
		},
		// Allow ngrok and other tunneling services for Telegram webhook development
		allowedHosts: ['.ngrok-free.dev', '.ngrok.io', '.ngrok.app', 'localhost'],
		watch: {
			followSymlinks: true,
			ignored: [
				'**/external_modules/**/svelte.config.js',
				'**/external_modules/**/.git/**',
				'**/external_modules/**/tsconfig.json',
				'**/external_modules/**/tsconfig.*.json'
			]
		}
	},

	test: {
		expect: { requireAssertions: true },

		projects: [
			{
				extends: './vite.config.ts',

				resolve: {
					preserveSymlinks: false
				},

				test: {
					name: 'client',

					browser: {
						enabled: true,
						provider: playwright(),
						instances: [{ browser: 'chromium', headless: true }]
					},

					include: ['src/**/*.svelte.{test,spec}.{js,ts}'],
					exclude: ['src/lib/server/**']
				}
			},

			{
				extends: './vite.config.ts',

				resolve: {
					preserveSymlinks: false
				},

				test: {
					name: 'server',
					environment: 'node',
					include: ['src/**/*.{test,spec}.{js,ts}'],
					exclude: ['src/**/*.svelte.{test,spec}.{js,ts}', '**/node_modules/**']
				}
			}
		]
	}
} as any);
