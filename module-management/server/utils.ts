import { existsSync, readdirSync, lstatSync, rmSync, mkdirSync, symlinkSync } from 'fs';
import path from 'path';
import { ModulePaths } from './paths';

/**
 * Utility functions for module management operations
 */

/**
 * Recursively get all files in a directory
 */
export function getAllFiles(dir: string): string[] {
	let results: string[] = [];
	const list = readdirSync(dir);
	list.forEach((file) => {
		file = path.join(dir, file);
		const stat = lstatSync(file);
		if (stat && stat.isDirectory()) {
			results = results.concat(getAllFiles(file));
		} else {
			results.push(file);
		}
	});
	return results;
}

/**
 * Check if a path is a broken symlink
 */
export function isBrokenSymlink(p: string): boolean {
	try {
		const stats = lstatSync(p);
		if (stats.isSymbolicLink()) {
			// Check if the target exists
			return !existsSync(p);
		}
		return false;
	} catch {
		return false;
	}
}

/**
 * Create a symlink with proper error handling
 */
export function createSymlink(source: string, dest: string): void {
	try {
		// Use rmSync with force to remove existing file/dir/symlink (even if broken)
		rmSync(dest, { recursive: true, force: true });

		const parent = path.dirname(dest);
		if (!existsSync(parent)) {
			mkdirSync(parent, { recursive: true });
		}

		const absoluteSource = path.resolve(source);
		const absoluteDest = path.resolve(dest);

		symlinkSync(absoluteSource, absoluteDest, 'dir');
	} catch (e: unknown) {
		const errorMessage = e instanceof Error ? e.message : String(e);
		throw new Error(`Failed to create symlink from ${source} to ${dest}: ${errorMessage}`);
	}
}

/**
 * Ensure all required parent directories exist for symlinks
 */
export function ensureSymlinkDirectories(): void {
	const parentDirs = [
		ModulePaths.INTERNAL_CONFIG_DIR,
		ModulePaths.UI_ROUTES_DIR,
		ModulePaths.API_ROUTES_DIR,
		ModulePaths.INTERNAL_MODULES_DIR
	];

	for (const dir of parentDirs) {
		if (!existsSync(dir)) {
			mkdirSync(dir, { recursive: true });
		}
	}
}

/**
 * Clean up module artifacts (symlinks) for a specific module
 */
export function cleanupModuleArtifacts(moduleId: string): void {
	// Only clean up source symlinks. SvelteKit-generated artifacts (.svelte-kit) will be
	// automatically regenerated by SvelteKit, and manually removing them causes race conditions
	// where SvelteKit tries to write to directories that have been deleted.
	const paths = [
		// Source Symlinks (these need cleanup)
		ModulePaths.getConfigSymlinkDest(moduleId),
		ModulePaths.getUIRoutesSymlinkDest(moduleId),
		ModulePaths.getAPIRoutesSymlinkDest(moduleId)
	];

	for (const p of paths) {
		try {
			// Use lstatSync to detect symlinks even if they are broken (existsSync returns false for broken symlinks)
			// Also handles normal files and directories
			if (existsSync(p) || isBrokenSymlink(p)) {
				rmSync(p, { recursive: true, force: true });
				console.log(`[ModuleManager] Cleaned up artifact: ${p}`);
			}
		} catch {
			// Path doesn't exist or couldn't be accessed, which is fine for cleanup
		}
	}
	// Note: We do NOT clean up .svelte-kit directories. SvelteKit manages these internally
	// and removing them while the dev server is running causes file write race conditions.
}

/**
 * Clean up orphaned symlinks in the specified directories
 */
export function cleanupOrphanedSymlinks(activeModuleIds: Set<string>): void {
	const symlinkDirs = [
		ModulePaths.INTERNAL_CONFIG_DIR,
		ModulePaths.INTERNAL_MODULES_DIR,
		ModulePaths.UI_ROUTES_DIR,
		ModulePaths.API_ROUTES_DIR
	];

	for (const dir of symlinkDirs) {
		if (!existsSync(dir)) continue;

		try {
			const items = readdirSync(dir, { withFileTypes: true });
			for (const item of items) {
				const itemPath = path.join(dir, item.name);
				const isSymlink = item.isSymbolicLink();
				const isBroken = isBrokenSymlink(itemPath);
				const isOrphaned = !activeModuleIds.has(item.name);

				if (isSymlink && (isBroken || isOrphaned)) {
					try {
						rmSync(itemPath, { recursive: true, force: true });
						console.log(`[ModuleManager] Removed orphaned/broken symlink: ${itemPath}`);
					} catch (e) {
						console.warn(`[ModuleManager] Failed to remove ${itemPath}: ${e}`);
					}
				}
			}
		} catch (e) {
			console.warn(`[ModuleManager] Error scanning directory ${dir}: ${e}`);
		}
	}
}